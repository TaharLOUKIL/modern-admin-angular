{"version":3,"file":"highlight.service.d.ts","sources":["highlight.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Observable } from 'rxjs';\nimport { HighlightConfig, HighlightResult, HighlightLibrary, HighlightOptions } from './highlight.model';\nimport { HighlightLoader } from './highlight.loader';\nexport declare class HighlightJS {\n    private _loader;\n    private _hljs;\n    get hljs(): HighlightLibrary | null;\n    constructor(_loader: HighlightLoader, options: HighlightOptions);\n    /**\n     * Core highlighting function.\n     * @param name Accepts a language name, or an alias\n     * @param value A string with the code to highlight.\n     * @param ignore_illegals When present and evaluates to a true value, forces highlighting to finish\n     * even in case of detecting illegal syntax for the language instead of throwing an exception.\n     * @param continuation An optional mode stack representing unfinished parsing.\n     * When present, the function will restart parsing from this state instead of initializing a new one\n     */\n    highlight(name: string, value: string, ignore_illegals: boolean, continuation?: any): Observable<HighlightResult>;\n    /**\n     * Highlighting with language detection.\n     * @param value Accepts a string with the code to highlight\n     * @param languageSubset An optional array of language names and aliases restricting detection to only those languages.\n     * The subset can also be set with configure, but the local parameter overrides the option if set.\n     */\n    highlightAuto(value: string, languageSubset: string[]): Observable<HighlightResult>;\n    /**\n     * Post-processing of the highlighted markup.\n     * Currently consists of replacing indentation TAB characters and using <br> tags instead of new-line characters.\n     * Options are set globally with configure.\n     * @param value Accepts a string with the highlighted markup\n     */\n    fixMarkup(value: string): Observable<string>;\n    /**\n     * Applies highlighting to a DOM node containing code.\n     * The function uses language detection by default but you can specify the language in the class attribute of the DOM node.\n     * See the class reference for all available language names and aliases.\n     * @param block The element to apply highlight on.\n     */\n    highlightBlock(block: HTMLElement): Observable<void>;\n    /**\n     * Configures global options:\n     * @param config HighlightJs configuration argument\n     */\n    configure(config: HighlightConfig): Observable<void>;\n    /**\n     * Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\n     */\n    initHighlighting(): Observable<void>;\n    /**\n     * Adds new language to the library under the specified name. Used mostly internally.\n     * @param name A string with the name of the language being registered\n     * @param language A function that returns an object which represents the language definition.\n     * The function is passed the hljs object to be able to use common regular expressions defined within it.\n     */\n    registerLanguage(name: string, language: () => any): Observable<HighlightLibrary>;\n    /**\n     * @return The languages names list.\n     */\n    listLanguages(): Observable<string[]>;\n    /**\n     * Looks up a language by name or alias.\n     * @param name Language name\n     * @return The language object if found, undefined otherwise.\n     */\n    getLanguage(name: string): Observable<any>;\n    /**\n     * Display line numbers\n     * @param el Code element\n     */\n    lineNumbersBlock(el: HTMLElement): Observable<any>;\n}\n"]}