import { __decorate, __assign } from 'tslib';
import { Injectable, InjectionToken, NgModule } from '@angular/core';
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { BLOCKUI_DEFAULT, BlockUIService, BlockUIModule } from 'ng-block-ui';
import { finalize } from 'rxjs/operators';

var BlockUIHttpSettings = /** @class */ (function () {
    function BlockUIHttpSettings() {
        this.settings = {};
    }
    BlockUIHttpSettings = __decorate([
        Injectable()
    ], BlockUIHttpSettings);
    return BlockUIHttpSettings;
}());

var BlockUIInterceptor = /** @class */ (function () {
    function BlockUIInterceptor(blockUIService, blockUIHttpSettings) {
        this.blockUIService = blockUIService;
        this.blockUIHttpSettings = blockUIHttpSettings;
        this.activeHttpRequests = 0;
    }
    BlockUIInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        var active = false;
        if (this.shouldBlock(request)) {
            this.blockUIService.start(BLOCKUI_DEFAULT);
        }
        return next.handle(request)
            .pipe(finalize(function () {
            if (_this.shouldBlock(request)) {
                var blockAllRequestsInProgress = _this.blockUIHttpSettings.settings.blockAllRequestsInProgress;
                var method = blockAllRequestsInProgress ? 'stop' : 'reset';
                _this.blockUIService[method](BLOCKUI_DEFAULT);
            }
        }));
    };
    BlockUIInterceptor.prototype.shouldBlock = function (request) {
        var method = request.method, urlWithParams = request.urlWithParams;
        var settings = this.blockUIHttpSettings.settings;
        var requestFilters = settings.requestFilters || [];
        return !requestFilters.some(function (f) {
            if (f && f.method && f.url) {
                return f.method.toUpperCase() === method && f.url.test(urlWithParams);
            }
            else if (typeof f === 'function') {
                return f(request);
            }
            return f.test(urlWithParams);
        });
    };
    BlockUIInterceptor.ctorParameters = function () { return [
        { type: BlockUIService },
        { type: BlockUIHttpSettings }
    ]; };
    BlockUIInterceptor = __decorate([
        Injectable()
    ], BlockUIInterceptor);
    return BlockUIInterceptor;
}());

// Needed for AOT compiling
var BlockUIHttpModuleSettings = new InjectionToken('BlockUIHttpModuleSettings');
function provideSettingsInstance(settings) {
    return {
        settings: __assign({ blockAllRequestsInProgress: true }, settings)
    };
}
var BlockUIHttpModule = /** @class */ (function () {
    function BlockUIHttpModule() {
    }
    BlockUIHttpModule_1 = BlockUIHttpModule;
    BlockUIHttpModule.forRoot = function (settings) {
        if (settings === void 0) { settings = {}; }
        return {
            ngModule: BlockUIHttpModule_1,
            providers: [
                {
                    provide: BlockUIHttpModuleSettings,
                    useValue: settings
                },
                {
                    provide: BlockUIHttpSettings,
                    useFactory: provideSettingsInstance,
                    deps: [BlockUIHttpModuleSettings]
                },
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: BlockUIInterceptor,
                    multi: true
                }
            ]
        };
    };
    var BlockUIHttpModule_1;
    BlockUIHttpModule = BlockUIHttpModule_1 = __decorate([
        NgModule({
            imports: [BlockUIModule]
        })
    ], BlockUIHttpModule);
    return BlockUIHttpModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { BlockUIHttpModule, BlockUIHttpModuleSettings as ɵa, provideSettingsInstance as ɵb, BlockUIHttpSettings as ɵc, BlockUIInterceptor as ɵd };
//# sourceMappingURL=ng-block-ui-http.js.map
