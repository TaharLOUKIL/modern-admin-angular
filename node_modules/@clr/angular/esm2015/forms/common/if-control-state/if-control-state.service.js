/*
 * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { NgControlService } from '../providers/ng-control.service';
export var CONTROL_STATE;
(function (CONTROL_STATE) {
    CONTROL_STATE["NONE"] = "NONE";
    CONTROL_STATE["VALID"] = "VALID";
    CONTROL_STATE["INVALID"] = "INVALID";
})(CONTROL_STATE || (CONTROL_STATE = {}));
export class IfControlStateService {
    constructor(ngControlService) {
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        // Implement our own status changes observable, since Angular controls don't
        this._statusChanges = new BehaviorSubject(CONTROL_STATE.NONE);
        // Wait for the control to be available
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            if (control) {
                this.control = control;
                // Subscribe to the status change events, only after touched
                // and emit the control
                this.subscriptions.push(this.control.statusChanges.subscribe(() => {
                    this.triggerStatusChange();
                }));
            }
        }));
    }
    get statusChanges() {
        return this._statusChanges.asObservable();
    }
    triggerStatusChange() {
        /* Check if control is defined and run the code only then */
        if (this.control) {
            // These status values are mutually exclusive, so a control
            // cannot be both valid AND invalid or invalid AND disabled.
            const status = CONTROL_STATE[this.control.status];
            this._statusChanges.next(this.control.touched && ['VALID', 'INVALID'].includes(status) ? status : CONTROL_STATE.NONE);
        }
    }
    // Clean up subscriptions
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
}
IfControlStateService.decorators = [
    { type: Injectable }
];
IfControlStateService.ctorParameters = () => [
    { type: NgControlService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtY29udHJvbC1zdGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZm9ybXMvY29tbW9uL2lmLWNvbnRyb2wtc3RhdGUvaWYtY29udHJvbC1zdGF0ZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFFSCxPQUFPLEVBQUUsVUFBVSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sRUFBYyxlQUFlLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBRW5FLE1BQU0sQ0FBTixJQUFZLGFBSVg7QUFKRCxXQUFZLGFBQWE7SUFDdkIsOEJBQWEsQ0FBQTtJQUNiLGdDQUFlLENBQUE7SUFDZixvQ0FBbUIsQ0FBQTtBQUNyQixDQUFDLEVBSlcsYUFBYSxLQUFiLGFBQWEsUUFJeEI7QUFHRCxNQUFNLE9BQU8scUJBQXFCO0lBVWhDLFlBQW9CLGdCQUFrQztRQUFsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBVDlDLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztRQUczQyw0RUFBNEU7UUFDcEUsbUJBQWMsR0FBbUMsSUFBSSxlQUFlLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBTS9GLHVDQUF1QztRQUN2QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdkQsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Z0JBQ3ZCLDREQUE0RDtnQkFDNUQsdUJBQXVCO2dCQUN2QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtvQkFDeEMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7Z0JBQzdCLENBQUMsQ0FBQyxDQUNILENBQUM7YUFDSDtRQUNILENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBcEJELElBQUksYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBb0JELG1CQUFtQjtRQUNqQiw0REFBNEQ7UUFDNUQsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLDJEQUEyRDtZQUMzRCw0REFBNEQ7WUFDNUQsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQ3RCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUM1RixDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQseUJBQXlCO0lBQ3pCLFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7OztZQTVDRixVQUFVOzs7WUFSRixnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjEgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuZXhwb3J0IGVudW0gQ09OVFJPTF9TVEFURSB7XG4gIE5PTkUgPSAnTk9ORScsXG4gIFZBTElEID0gJ1ZBTElEJyxcbiAgSU5WQUxJRCA9ICdJTlZBTElEJyxcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElmQ29udHJvbFN0YXRlU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgLy8gSW1wbGVtZW50IG91ciBvd24gc3RhdHVzIGNoYW5nZXMgb2JzZXJ2YWJsZSwgc2luY2UgQW5ndWxhciBjb250cm9scyBkb24ndFxuICBwcml2YXRlIF9zdGF0dXNDaGFuZ2VzOiBCZWhhdmlvclN1YmplY3Q8Q09OVFJPTF9TVEFURT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KENPTlRST0xfU1RBVEUuTk9ORSk7XG4gIGdldCBzdGF0dXNDaGFuZ2VzKCk6IE9ic2VydmFibGU8Q09OVFJPTF9TVEFURT4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIGNvbnRyb2wgdG8gYmUgYXZhaWxhYmxlXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdGF0dXMgY2hhbmdlIGV2ZW50cywgb25seSBhZnRlciB0b3VjaGVkXG4gICAgICAgICAgLy8gYW5kIGVtaXQgdGhlIGNvbnRyb2xcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlclN0YXR1c0NoYW5nZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICB0cmlnZ2VyU3RhdHVzQ2hhbmdlKCkge1xuICAgIC8qIENoZWNrIGlmIGNvbnRyb2wgaXMgZGVmaW5lZCBhbmQgcnVuIHRoZSBjb2RlIG9ubHkgdGhlbiAqL1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIC8vIFRoZXNlIHN0YXR1cyB2YWx1ZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gYSBjb250cm9sXG4gICAgICAvLyBjYW5ub3QgYmUgYm90aCB2YWxpZCBBTkQgaW52YWxpZCBvciBpbnZhbGlkIEFORCBkaXNhYmxlZC5cbiAgICAgIGNvbnN0IHN0YXR1cyA9IENPTlRST0xfU1RBVEVbdGhpcy5jb250cm9sLnN0YXR1c107XG4gICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLm5leHQoXG4gICAgICAgIHRoaXMuY29udHJvbC50b3VjaGVkICYmIFsnVkFMSUQnLCAnSU5WQUxJRCddLmluY2x1ZGVzKHN0YXR1cykgPyBzdGF0dXMgOiBDT05UUk9MX1NUQVRFLk5PTkVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgc3Vic2NyaXB0aW9uc1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iXX0=