/*
 * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { Page } from './page';
import { StateDebouncer } from './state-debouncer.provider';
export class FiltersProvider {
    constructor(_page, stateDebouncer) {
        this._page = _page;
        this.stateDebouncer = stateDebouncer;
        /**
         * This subject is the list of filters that changed last, not the whole list.
         * We emit a list rather than just one filter to allow batch changes to several at once.
         */
        this._change = new Subject();
        /**
         * List of all filters, whether they're active or not
         */
        this._all = [];
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    get change() {
        return this._change.asObservable();
    }
    /**
     * Tests if at least one filter is currently active
     */
    hasActiveFilters() {
        // We do not use getActiveFilters() because this function will be called much more often
        // and stopping the loop early might be relevant.
        for (const { filter } of this._all) {
            if (filter && filter.isActive()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns a list of all currently active filters
     */
    getActiveFilters() {
        const ret = [];
        for (const { filter } of this._all) {
            if (filter && filter.isActive()) {
                ret.push(filter);
            }
        }
        return ret;
    }
    /**
     * Registers a filter, and returns a deregistration function
     */
    add(filter) {
        const subscription = filter.changes.subscribe(() => this.resetPageAndEmitFilterChange([filter]));
        let hasUnregistered = false;
        const registered = new RegisteredFilter(filter, () => {
            if (hasUnregistered) {
                return;
            }
            subscription.unsubscribe();
            const matchIndex = this._all.findIndex(item => item.filter === filter);
            if (matchIndex >= 0) {
                this._all.splice(matchIndex, 1);
            }
            if (filter.isActive()) {
                this.resetPageAndEmitFilterChange([]);
            }
            hasUnregistered = true;
        });
        this._all.push(registered);
        if (filter.isActive()) {
            this.resetPageAndEmitFilterChange([filter]);
        }
        return registered;
    }
    /**
     * Accepts an item if it is accepted by all currently active filters
     */
    accepts(item) {
        for (const { filter } of this._all) {
            if (filter && filter.isActive() && !filter.accepts(item)) {
                return false;
            }
        }
        return true;
    }
    resetPageAndEmitFilterChange(filters) {
        this.stateDebouncer.changeStart();
        // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
        // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
        this._page.current = 1;
        this._change.next(filters);
        this.stateDebouncer.changeDone();
    }
}
FiltersProvider.decorators = [
    { type: Injectable }
];
FiltersProvider.ctorParameters = () => [
    { type: Page },
    { type: StateDebouncer }
];
export class RegisteredFilter {
    constructor(filter, unregister) {
        this.filter = filter;
        this.unregister = unregister;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2ZpbHRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUNILE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUcvQixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUc1RCxNQUFNLE9BQU8sZUFBZTtJQUMxQixZQUFvQixLQUFXLEVBQVUsY0FBOEI7UUFBbkQsVUFBSyxHQUFMLEtBQUssQ0FBTTtRQUFVLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUN2RTs7O1dBR0c7UUFDSyxZQUFPLEdBQUcsSUFBSSxPQUFPLEVBQW1DLENBQUM7UUFNakU7O1dBRUc7UUFDSyxTQUFJLEdBQXlELEVBQUUsQ0FBQztJQWRFLENBQUM7SUFNM0UscUZBQXFGO0lBQ3JGLElBQVcsTUFBTTtRQUNmLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBT0Q7O09BRUc7SUFDSSxnQkFBZ0I7UUFDckIsd0ZBQXdGO1FBQ3hGLGlEQUFpRDtRQUNqRCxLQUFLLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2xDLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDL0IsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0I7UUFDckIsTUFBTSxHQUFHLEdBQW9DLEVBQUUsQ0FBQztRQUNoRCxLQUFLLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2xDLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDL0IsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNsQjtTQUNGO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSSxHQUFHLENBQTBDLE1BQVM7UUFDM0QsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pHLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUM1QixNQUFNLFVBQVUsR0FBRyxJQUFJLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7WUFDbkQsSUFBSSxlQUFlLEVBQUU7Z0JBQ25CLE9BQU87YUFDUjtZQUNELFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUMzQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLENBQUM7WUFDdkUsSUFBSSxVQUFVLElBQUksQ0FBQyxFQUFFO2dCQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDakM7WUFDRCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDckIsSUFBSSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZDO1lBQ0QsZUFBZSxHQUFHLElBQUksQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNCLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3JCLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDN0M7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPLENBQUMsSUFBTztRQUNwQixLQUFLLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2xDLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7U0FDRjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVPLDRCQUE0QixDQUFDLE9BQXdDO1FBQzNFLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbEMsNEdBQTRHO1FBQzVHLDJHQUEyRztRQUMzRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNuQyxDQUFDOzs7WUEzRkYsVUFBVTs7O1lBSEYsSUFBSTtZQUNKLGNBQWM7O0FBZ0d2QixNQUFNLE9BQU8sZ0JBQWdCO0lBQzNCLFlBQW1CLE1BQVMsRUFBUyxVQUFzQjtRQUF4QyxXQUFNLEdBQU4sTUFBTSxDQUFHO1FBQVMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUFHLENBQUM7Q0FDaEUiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjEgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGaWx0ZXJzUHJvdmlkZXI8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlOiBQYWdlLCBwcml2YXRlIHN0YXRlRGVib3VuY2VyOiBTdGF0ZURlYm91bmNlcikge31cbiAgLyoqXG4gICAqIFRoaXMgc3ViamVjdCBpcyB0aGUgbGlzdCBvZiBmaWx0ZXJzIHRoYXQgY2hhbmdlZCBsYXN0LCBub3QgdGhlIHdob2xlIGxpc3QuXG4gICAqIFdlIGVtaXQgYSBsaXN0IHJhdGhlciB0aGFuIGp1c3Qgb25lIGZpbHRlciB0byBhbGxvdyBiYXRjaCBjaGFuZ2VzIHRvIHNldmVyYWwgYXQgb25jZS5cbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+W10+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCBmaWx0ZXJzLCB3aGV0aGVyIHRoZXkncmUgYWN0aXZlIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBSZWdpc3RlcmVkRmlsdGVyPFQsIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PltdID0gW107XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGF0IGxlYXN0IG9uZSBmaWx0ZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgcHVibGljIGhhc0FjdGl2ZUZpbHRlcnMoKTogYm9vbGVhbiB7XG4gICAgLy8gV2UgZG8gbm90IHVzZSBnZXRBY3RpdmVGaWx0ZXJzKCkgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG11Y2ggbW9yZSBvZnRlblxuICAgIC8vIGFuZCBzdG9wcGluZyB0aGUgbG9vcCBlYXJseSBtaWdodCBiZSByZWxldmFudC5cbiAgICBmb3IgKGNvbnN0IHsgZmlsdGVyIH0gb2YgdGhpcy5fYWxsKSB7XG4gICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZUZpbHRlcnMoKTogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSB7XG4gICAgY29uc3QgcmV0OiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdID0gW107XG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICByZXQucHVzaChmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGZpbHRlciwgYW5kIHJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvblxuICAgKi9cbiAgcHVibGljIGFkZDxGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+KGZpbHRlcjogRik6IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZpbHRlci5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW2ZpbHRlcl0pKTtcbiAgICBsZXQgaGFzVW5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgY29uc3QgcmVnaXN0ZXJlZCA9IG5ldyBSZWdpc3RlcmVkRmlsdGVyKGZpbHRlciwgKCkgPT4ge1xuICAgICAgaWYgKGhhc1VucmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSB0aGlzLl9hbGwuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5maWx0ZXIgPT09IGZpbHRlcik7XG4gICAgICBpZiAobWF0Y2hJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX2FsbC5zcGxpY2UobWF0Y2hJbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5yZXNldFBhZ2VBbmRFbWl0RmlsdGVyQ2hhbmdlKFtdKTtcbiAgICAgIH1cbiAgICAgIGhhc1VucmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5fYWxsLnB1c2gocmVnaXN0ZXJlZCk7XG4gICAgaWYgKGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW2ZpbHRlcl0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGFuIGl0ZW0gaWYgaXQgaXMgYWNjZXB0ZWQgYnkgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGFjY2VwdHMoaXRlbTogVCk6IGJvb2xlYW4ge1xuICAgIGZvciAoY29uc3QgeyBmaWx0ZXIgfSBvZiB0aGlzLl9hbGwpIHtcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKCkgJiYgIWZpbHRlci5hY2NlcHRzKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoZmlsdGVyczogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSkge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAvLyBmaWx0ZXJpbmcgbWF5IGNoYW5nZSB0aGUgcGFnZSBudW1iZXIgc3VjaCB0aGF0IGN1cnJlbnQgcGFnZSBudW1iZXIgZG9lc24ndCBleGlzdCBpbiB0aGUgZmlsdGVyZWQgZGF0YXNldC5cbiAgICAvLyBTbyBoZXJlIHdlIGFsd2F5cyBzZXQgdGhlIGN1cnJlbnQgcGFnZSB0byAxIHNvIHRoYXQgaXQnbGwgZmV0Y2ggZmlyc3QgcGFnZSdzIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gZmlsdGVyLlxuICAgIHRoaXMuX3BhZ2UuY3VycmVudCA9IDE7XG4gICAgdGhpcy5fY2hhbmdlLm5leHQoZmlsdGVycyk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRiBleHRlbmRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEYsIHB1YmxpYyB1bnJlZ2lzdGVyOiAoKSA9PiB2b2lkKSB7fVxufVxuIl19