/*
 * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChildren, ElementRef, HostListener, Input, } from '@angular/core';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNode } from './tree-node';
export class ClrTree {
    constructor(featuresService, focusManagerService, el) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.el = el;
        this.subscriptions = [];
        this.tabindex = 0;
    }
    set lazy(value) {
        this.featuresService.eager = !value;
    }
    get isMultiSelectable() {
        return this.featuresService.selectable && this.rootNodes.length > 0;
    }
    onFocusIn(event) {
        if (event.target === this.el.nativeElement) {
            // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
            // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
            this.focusManagerService.focusFirstVisibleNode();
            // when the first child gets focus,
            // tree should no longer have tabindex of 0;
            delete this.tabindex;
        }
    }
    ngAfterContentInit() {
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
            this.setRootNodes();
        }));
    }
    setRootNodes() {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(node => node._model).filter(node => !node.parent);
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrTree.decorators = [
    { type: Component, args: [{
                selector: 'clr-tree',
                template: `
    <ng-content></ng-content>
    <clr-recursive-children
      *ngIf="featuresService.recursion"
      [children]="featuresService.recursion.root"
    ></clr-recursive-children>
  `,
                providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
                host: {
                    '[attr.tabindex]': 'tabindex',
                    '[attr.role]': '"tree"',
                    '[attr.aria-multiselectable]': 'isMultiSelectable',
                }
            },] }
];
ClrTree.ctorParameters = () => [
    { type: TreeFeaturesService },
    { type: TreeFocusManagerService },
    { type: ElementRef }
];
ClrTree.propDecorators = {
    lazy: [{ type: Input, args: ['clrLazy',] }],
    onFocusIn: [{ type: HostListener, args: ['focusin', ['$event'],] }],
    rootNodes: [{ type: ContentChildren, args: [ClrTreeNode,] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2RhdGEvdHJlZS12aWV3L3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFFTCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxHQUdOLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFrQjFDLE1BQU0sT0FBTyxPQUFPO0lBQ2xCLFlBQ1MsZUFBdUMsRUFDdEMsbUJBQStDLEVBQy9DLEVBQWM7UUFGZixvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUE0QjtRQUMvQyxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBR2hCLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztRQU8zQyxhQUFRLEdBQUcsQ0FBQyxDQUFDO0lBVFYsQ0FBQztJQUlKLElBQ0ksSUFBSSxDQUFDLEtBQWM7UUFDckIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUM7SUFDdEMsQ0FBQztJQUlELElBQUksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFHRCxTQUFTLENBQUMsS0FBaUI7UUFDekIsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFO1lBQzFDLDZIQUE2SDtZQUM3SCxxSEFBcUg7WUFDckgsSUFBSSxDQUFDLG1CQUFtQixDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFFakQsbUNBQW1DO1lBQ25DLDRDQUE0QztZQUM1QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBSUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNwQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxZQUFZO1FBQ2xCLDBDQUEwQztRQUMxQyxvRUFBb0U7UUFDcEUseUVBQXlFO1FBQ3pFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7OztZQXJFRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLFFBQVEsRUFBRTs7Ozs7O0dBTVQ7Z0JBQ0QsU0FBUyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsdUJBQXVCLENBQUM7Z0JBQzVELElBQUksRUFBRTtvQkFDSixpQkFBaUIsRUFBRSxVQUFVO29CQUM3QixhQUFhLEVBQUUsUUFBUTtvQkFDdkIsNkJBQTZCLEVBQUUsbUJBQW1CO2lCQUNuRDthQUNGOzs7WUFsQlEsbUJBQW1CO1lBRG5CLHVCQUF1QjtZQVA5QixVQUFVOzs7bUJBb0NULEtBQUssU0FBQyxTQUFTO3dCQVdmLFlBQVksU0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUM7d0JBYWxDLGVBQWUsU0FBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIxIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vdHJlZS1mb2N1cy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSwgVFJFRV9GRUFUVVJFU19QUk9WSURFUiB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdHJlZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjbHItcmVjdXJzaXZlLWNoaWxkcmVuXG4gICAgICAqbmdJZj1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cIlxuICAgICAgW2NoaWxkcmVuXT1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24ucm9vdFwiXG4gICAgPjwvY2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbj5cbiAgYCxcbiAgcHJvdmlkZXJzOiBbVFJFRV9GRUFUVVJFU19QUk9WSURFUiwgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJpbmRleCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZVwiJyxcbiAgICAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJ2lzTXVsdGlTZWxlY3RhYmxlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXJTZXJ2aWNlOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmXG4gICkge31cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJMYXp5JylcbiAgc2V0IGxhenkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciA9ICF2YWx1ZTtcbiAgfVxuXG4gIHRhYmluZGV4ID0gMDtcblxuICBnZXQgaXNNdWx0aVNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgJiYgdGhpcy5yb290Tm9kZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIEFmdGVyIGRpc2N1c3Npbmcgd2l0aCB0aGUgdGVhbSwgSSd2ZSBtYWRlIGl0IHNvIHRoYXQgd2hlbiB0aGUgdHJlZSByZWNlaXZlcyBmb2N1cywgdGhlIGZpcnN0IHZpc2libGUgbm9kZSB3aWxsIGJlIGZvY3VzZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmcm9tIHRoZSBwYWdlIHNjcm9sbGluZyBhYnJ1cHRseSB0byB0aGUgZmlyc3Qgc2VsZWN0ZWQgbm9kZSBpZiBpdCBleGlzdCBpbiBhIGRlZXBseSBuZXN0ZWQgdHJlZS5cbiAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcblxuICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgY2hpbGQgZ2V0cyBmb2N1cyxcbiAgICAgIC8vIHRyZWUgc2hvdWxkIG5vIGxvbmdlciBoYXZlIHRhYmluZGV4IG9mIDA7XG4gICAgICBkZWxldGUgdGhpcy50YWJpbmRleDtcbiAgICB9XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKENsclRyZWVOb2RlKSBwcml2YXRlIHJvb3ROb2RlczogUXVlcnlMaXN0PENsclRyZWVOb2RlPFQ+PjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm9vdE5vZGVzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Um9vdE5vZGVzKCk6IHZvaWQge1xuICAgIC8vIGlmIG5vZGUgaGFzIG5vIHBhcmVudCwgaXQncyBhIHJvb3Qgbm9kZVxuICAgIC8vIGZvciByZWN1cnNpdmUgdHJlZSwgdGhpcy5yb290Tm9kZXMgcmVnaXN0ZXJzIGFsc28gbmVzdGVkIGNoaWxkcmVuXG4gICAgLy8gc28gd2UgaGF2ZSB0byB1c2UgZmlsdGVyIHRvIGV4dHJhY3QgdGhlIG9uZXMgdGhhdCBhcmUgdHJ1bHkgcm9vdCBub2Rlc1xuICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5yb290Tm9kZU1vZGVscyA9IHRoaXMucm9vdE5vZGVzLm1hcChub2RlID0+IG5vZGUuX21vZGVsKS5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIl19