/*
 * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { animate, style, transition, trigger, state } from '@angular/animations';
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, Inject, Injector, Input, Optional, Output, PLATFORM_ID, SkipSelf, ViewChild, } from '@angular/core';
import { debounceTime, filter } from 'rxjs/operators';
import { KeyCodes } from './../../utils/enums/key-codes.enum';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { keyValidator, preventArrowKeyScroll } from '../../utils/focus/key-focus/util';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { DeclarativeTreeNodeModel } from './models/declarative-tree-node.model';
import { ClrSelectedState } from './models/selected-state.enum';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { ClrTreeNodeLink } from './tree-node-link';
const LVIEW_CONTEXT_INDEX = 8;
export class ClrTreeNode {
    constructor(nodeId, platformId, parent, featuresService, expandService, commonStrings, focusManager, injector) {
        this.nodeId = nodeId;
        this.platformId = platformId;
        this.featuresService = featuresService;
        this.expandService = expandService;
        this.commonStrings = commonStrings;
        this.focusManager = focusManager;
        this.STATES = ClrSelectedState;
        this.skipEmitChange = false;
        this.isModelLoading = false;
        this.selectedChange = new EventEmitter(false);
        this.expandedChange = new EventEmitter();
        this.subscriptions = [];
        this.contentContainerTabindex = -1;
        if (this.featuresService.recursion) {
            // I'm completely stuck, we have to hack into private properties until either
            // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
            // are fixed
            // This is for non-ivy implementations
            if (injector.view) {
                this._model = injector.view.context.clrModel;
            }
            else {
                // Ivy puts this on a specific index of a _lView property
                this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
            }
        }
        else {
            // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
            this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
        }
        this._model.nodeId = this.nodeId;
    }
    isExpandable() {
        if (typeof this.expandable !== 'undefined') {
            return this.expandable;
        }
        return !!this.expandService.expandable || (this._model.children && this._model.children.length > 0);
    }
    get selected() {
        return this._model.selected.value;
    }
    set selected(value) {
        this.featuresService.selectable = true;
        // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
        // This shouldn't happen with strict typing on the app's side, but it's not up to us.
        if (value === null || typeof value === 'undefined') {
            value = ClrSelectedState.UNSELECTED;
        }
        // We match booleans to the corresponding ClrSelectedState
        if (typeof value === 'boolean') {
            value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
        }
        // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
        // See https://github.com/vmware/clarity/issues/3073
        this.skipEmitChange = true;
        this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
        this.skipEmitChange = false;
    }
    get ariaSelected() {
        return this.featuresService.selectable ? this._model.selected.value === ClrSelectedState.SELECTED : null;
    }
    // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
    // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
    // case, you can't use a structural directive, it would need to go on an ng-container.
    get expanded() {
        return this.expandService.expanded;
    }
    set expanded(value) {
        this.expandService.expanded = value;
    }
    ngOnInit() {
        this._model.expanded = this.expanded;
        this.subscriptions.push(this._model.selected.pipe(filter(() => !this.skipEmitChange)).subscribe(value => {
            this.selectedChange.emit(value);
        }));
        this.subscriptions.push(this.expandService.expandChange.subscribe(value => {
            this.expandedChange.emit(value);
            this._model.expanded = value;
        }));
        this.subscriptions.push(this.focusManager.focusRequest.subscribe(nodeId => {
            if (this.nodeId === nodeId) {
                this.focusTreeNode();
            }
        }), this.focusManager.focusChange.subscribe(nodeId => {
            this.checkTabIndex(nodeId);
        }));
        this.subscriptions.push(this._model.loading$.pipe(debounceTime(0)).subscribe(isLoading => (this.isModelLoading = isLoading)));
    }
    ngOnDestroy() {
        this._model.destroy();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    get treeNodeLink() {
        return this.treeNodeLinkList && this.treeNodeLinkList.first;
    }
    setTabIndex(value) {
        this.contentContainerTabindex = value;
        this.contentContainer.nativeElement.setAttribute('tabindex', value);
    }
    checkTabIndex(nodeId) {
        if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
            this.setTabIndex(-1);
        }
    }
    focusTreeNode() {
        if (isPlatformBrowser(this.platformId) && document.activeElement !== this.contentContainer.nativeElement) {
            this.setTabIndex(0);
            this.contentContainer.nativeElement.focus();
        }
    }
    broadcastFocusOnContainer() {
        this.focusManager.broadcastFocusedNode(this.nodeId);
    }
    onKeyDown(event) {
        // Two reasons to prevent default behavior:
        // 1. to prevent scrolling on arrow keys
        // 2. Assistive Technology focus differs from Keyboard focus behavior.
        //    By default, pressing arrow key makes AT focus go into the nested content of the item.
        preventArrowKeyScroll(event);
        // https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-22
        switch (keyValidator(event.key)) {
            case KeyCodes.ArrowUp:
                this.focusManager.focusNodeAbove(this._model);
                break;
            case KeyCodes.ArrowDown:
                this.focusManager.focusNodeBelow(this._model);
                break;
            case KeyCodes.ArrowRight:
                this.expandOrFocusFirstChild();
                break;
            case KeyCodes.ArrowLeft:
                this.collapseOrFocusParent();
                break;
            case KeyCodes.Home:
                this.focusManager.focusFirstVisibleNode();
                break;
            case KeyCodes.End:
                this.focusManager.focusLastVisibleNode();
                break;
            case KeyCodes.Enter:
                this.triggerDefaultAction();
                break;
            case KeyCodes.Space:
                // to prevent scrolling on space key in this specific case
                event.preventDefault();
                this.triggerDefaultAction();
                break;
            default:
                break;
        }
    }
    expandOrFocusFirstChild() {
        if (this.expanded) {
            // if the node is already expanded and has children, focus its very first child
            if (this._model.children.length > 0) {
                this.focusManager.focusNodeBelow(this._model);
            }
        }
        else {
            // we must check if the node is expandable, in order to set .expanded to true from false
            // because we shouldn't set .expanded to true if it's not expandable node
            if (this.isExpandable()) {
                this.expandService.expanded = true;
            }
        }
    }
    collapseOrFocusParent() {
        if (this.expanded) {
            this.expandService.expanded = false;
        }
        else {
            this.focusManager.focusParent(this._model);
        }
    }
    triggerDefaultAction() {
        if (this.treeNodeLink) {
            this.treeNodeLink.activate();
        }
        else {
            if (this.featuresService.selectable) {
                this._model.toggleSelection(this.featuresService.eager);
            }
        }
    }
}
ClrTreeNode.decorators = [
    { type: Component, args: [{
                selector: 'clr-tree-node',
                template: "<!--\n  ~ Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  #contentContainer\n  role=\"treeitem\"\n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\"\n  (keydown)=\"onKeyDown($event)\"\n  (focus)=\"broadcastFocusOnContainer()\"\n>\n  <button\n    *ngIf=\"isExpandable() && !isModelLoading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\"\n    (focus)=\"focusTreeNode()\"\n  >\n    <cds-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"angle\"\n      [attr.direction]=\"expandService.expanded ? 'down' : 'right'\"\n    ></cds-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || isModelLoading\">\n    <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input\n      aria-hidden=\"true\"\n      type=\"checkbox\"\n      id=\"{{nodeId}}-check\"\n      class=\"clr-checkbox\"\n      [checked]=\"_model.selected.value === STATES.SELECTED\"\n      [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n      (change)=\"_model.toggleSelection(featuresService.eager)\"\n      (focus)=\"focusTreeNode()\"\n      tabindex=\"-1\"\n    />\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\">\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable\">\n      <span *ngIf=\"ariaSelected\"> selected </span>\n      <span *ngIf=\"!ariaSelected\"> unselected </span>\n    </div>\n  </div>\n</div>\n<div\n  class=\"clr-treenode-children\"\n  [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n  [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\"\n>\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n",
                providers: [
                    UNIQUE_ID_PROVIDER,
                    TREE_FEATURES_PROVIDER,
                    IfExpandService,
                    { provide: LoadingListener, useExisting: IfExpandService },
                ],
                animations: [
                    trigger('toggleChildrenAnim', [
                        transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
                        transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
                        state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
                        state('collapsed', style({ height: 0 })),
                    ]),
                ],
                host: {
                    '[attr.role]': '"treeitem"',
                    '[class.clr-tree-node]': 'true',
                }
            },] }
];
ClrTreeNode.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ClrTreeNode, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: TreeFeaturesService },
    { type: IfExpandService },
    { type: ClrCommonStringsService },
    { type: TreeFocusManagerService },
    { type: Injector }
];
ClrTreeNode.propDecorators = {
    selected: [{ type: Input, args: ['clrSelected',] }],
    selectedChange: [{ type: Output, args: ['clrSelectedChange',] }],
    expandable: [{ type: Input, args: ['clrExpandable',] }],
    expanded: [{ type: Input, args: ['clrExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrExpandedChange',] }],
    contentContainer: [{ type: ViewChild, args: ['contentContainer', { read: ElementRef, static: true },] }],
    treeNodeLinkList: [{ type: ContentChildren, args: [ClrTreeNodeLink, { descendants: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFFSCxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFDTCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osTUFBTSxFQUNOLFFBQVEsRUFDUixLQUFLLEVBR0wsUUFBUSxFQUNSLE1BQU0sRUFDTixXQUFXLEVBRVgsUUFBUSxFQUNSLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXRELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDOUUsT0FBTyxFQUFFLFlBQVksRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQztBQUM5RixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDdkUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDaEYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFaEUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHNC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LENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ2pHLEtBQUssQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQzt3QkFDbEUsS0FBSyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztxQkFDekMsQ0FBQztpQkFDSDtnQkFDRCxJQUFJLEVBQUU7b0JBQ0osYUFBYSxFQUFFLFlBQVk7b0JBQzNCLHVCQUF1QixFQUFFLE1BQU07aUJBQ2hDO2FBQ0Y7Ozt5Q0FPSSxNQUFNLFNBQUMsU0FBUzs0Q0FDaEIsTUFBTSxTQUFDLFdBQVc7WUFHWCxXQUFXLHVCQUZsQixRQUFRLFlBQ1IsUUFBUTtZQXJDSixtQkFBbUI7WUFSbkIsZUFBZTtZQUVmLHVCQUF1QjtZQU92Qix1QkFBdUI7WUF4QjlCLFFBQVE7Ozt1QkErRlAsS0FBSyxTQUFDLGFBQWE7NkJBc0JuQixNQUFNLFNBQUMsbUJBQW1CO3lCQVExQixLQUFLLFNBQUMsZUFBZTt1QkFLckIsS0FBSyxTQUFDLGFBQWE7NkJBUW5CLE1BQU0sU0FBQyxtQkFBbUI7K0JBSzFCLFNBQVMsU0FBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTsrQkF1Q2hFLGVBQWUsU0FBQyxlQUFlLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIxIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciwgc3RhdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUExBVEZPUk1fSUQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2tpcFNlbGYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBLZXlDb2RlcyB9IGZyb20gJy4vLi4vLi4vdXRpbHMvZW51bXMva2V5LWNvZGVzLmVudW0nO1xuaW1wb3J0IHsgSWZFeHBhbmRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtZXhwYW5kZWQuc2VydmljZSc7XG5pbXBvcnQgeyBrZXlWYWxpZGF0b3IsIHByZXZlbnRBcnJvd0tleVNjcm9sbCB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2tleS1mb2N1cy91dGlsJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9kZWNsYXJhdGl2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQ2xyU2VsZWN0ZWRTdGF0ZSB9IGZyb20gJy4vbW9kZWxzL3NlbGVjdGVkLXN0YXRlLmVudW0nO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBUcmVlRmVhdHVyZXNTZXJ2aWNlLCBUUkVFX0ZFQVRVUkVTX1BST1ZJREVSIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZm9jdXMtbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlTGluayB9IGZyb20gJy4vdHJlZS1ub2RlLWxpbmsnO1xuXG5jb25zdCBMVklFV19DT05URVhUX0lOREVYID0gODtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRyZWUtbm9kZScsXG4gIHRlbXBsYXRlVXJsOiAnLi90cmVlLW5vZGUuaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIFVOSVFVRV9JRF9QUk9WSURFUixcbiAgICBUUkVFX0ZFQVRVUkVTX1BST1ZJREVSLFxuICAgIElmRXhwYW5kU2VydmljZSxcbiAgICB7IHByb3ZpZGU6IExvYWRpbmdMaXN0ZW5lciwgdXNlRXhpc3Rpbmc6IElmRXhwYW5kU2VydmljZSB9LFxuICBdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcigndG9nZ2xlQ2hpbGRyZW5BbmltJywgW1xuICAgICAgdHJhbnNpdGlvbignY29sbGFwc2VkID0+IGV4cGFuZGVkJywgW3N0eWxlKHsgaGVpZ2h0OiAwIH0pLCBhbmltYXRlKDIwMCwgc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSldKSxcbiAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkID0+IGNvbGxhcHNlZCcsIFtzdHlsZSh7IGhlaWdodDogJyonIH0pLCBhbmltYXRlKDIwMCwgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpXSksXG4gICAgICBzdGF0ZSgnZXhwYW5kZWQnLCBzdHlsZSh7IGhlaWdodDogJyonLCAnb3ZlcmZsb3cteSc6ICd2aXNpYmxlJyB9KSksXG4gICAgICBzdGF0ZSgnY29sbGFwc2VkJywgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpLFxuICAgIF0pLFxuICBdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZWl0ZW1cIicsXG4gICAgJ1tjbGFzcy5jbHItdHJlZS1ub2RlXSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZU5vZGU8VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIFNUQVRFUyA9IENsclNlbGVjdGVkU3RhdGU7XG4gIHByaXZhdGUgc2tpcEVtaXRDaGFuZ2UgPSBmYWxzZTtcbiAgaXNNb2RlbExvYWRpbmcgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFVOSVFVRV9JRCkgcHVibGljIG5vZGVJZDogc3RyaW5nLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogYW55LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwYXJlbnQ6IENsclRyZWVOb2RlPFQ+LFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHVibGljIGV4cGFuZFNlcnZpY2U6IElmRXhwYW5kU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXI6IFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlPFQ+LFxuICAgIGluamVjdG9yOiBJbmplY3RvclxuICApIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uKSB7XG4gICAgICAvLyBJJ20gY29tcGxldGVseSBzdHVjaywgd2UgaGF2ZSB0byBoYWNrIGludG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIHVudGlsIGVpdGhlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTQ5MzUgb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU5OThcbiAgICAgIC8vIGFyZSBmaXhlZFxuICAgICAgLy8gVGhpcyBpcyBmb3Igbm9uLWl2eSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgIGlmICgoaW5qZWN0b3IgYXMgYW55KS52aWV3KSB7XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkudmlldy5jb250ZXh0LmNsck1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXZ5IHB1dHMgdGhpcyBvbiBhIHNwZWNpZmljIGluZGV4IG9mIGEgX2xWaWV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkuX2xWaWV3W0xWSUVXX0NPTlRFWFRfSU5ERVhdLmNsck1vZGVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBjYXN0IGZvciBub3csIG5vdCBzdXJlIGhvdyB0byB0aWUgdGhlIGNvcnJlY3QgdHlwZSBoZXJlIHRvIGZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbChwYXJlbnQgPyAocGFyZW50Ll9tb2RlbCBhcyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4pIDogbnVsbCk7XG4gICAgfVxuICAgIHRoaXMuX21vZGVsLm5vZGVJZCA9IHRoaXMubm9kZUlkO1xuICB9XG5cbiAgX21vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xuXG4gIGlzRXhwYW5kYWJsZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZXhwYW5kYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGU7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRhYmxlIHx8ICh0aGlzLl9tb2RlbC5jaGlsZHJlbiAmJiB0aGlzLl9tb2RlbC5jaGlsZHJlbi5sZW5ndGggPiAwKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyU2VsZWN0ZWQnKVxuICBnZXQgc2VsZWN0ZWQoKTogQ2xyU2VsZWN0ZWRTdGF0ZSB8IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5zZWxlY3RlZC52YWx1ZTtcbiAgfVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuKSB7XG4gICAgdGhpcy5mZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgZmFsc3kgc3RhdGVzIGxpa2UgbnVsbCBvciB1bmRlZmluZWQgYmVjYXVzZSBpdCdzIGp1c3QgZWFzaWVyIHRoYW4gYW5zd2VyaW5nIHF1ZXN0aW9ucy5cbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gd2l0aCBzdHJpY3QgdHlwaW5nIG9uIHRoZSBhcHAncyBzaWRlLCBidXQgaXQncyBub3QgdXAgdG8gdXMuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEO1xuICAgIH1cbiAgICAvLyBXZSBtYXRjaCBib29sZWFucyB0byB0aGUgY29ycmVzcG9uZGluZyBDbHJTZWxlY3RlZFN0YXRlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRCA6IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgcHJvcGFnYXRlIG9ubHkgaWYgdGhlIHRyZWUgaXMgaW4gc21hcnQgbW9kZSwgYW5kIHNraXAgZW1pdHRpbmcgdGhlIG91dHB1dCB3aGVuIHdlIHNldCB0aGUgaW5wdXRcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8zMDczXG4gICAgdGhpcy5za2lwRW1pdENoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fbW9kZWwuc2V0U2VsZWN0ZWQodmFsdWUsIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyLCB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlcik7XG4gICAgdGhpcy5za2lwRW1pdENoYW5nZSA9IGZhbHNlO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyU2VsZWN0ZWRTdGF0ZT4oZmFsc2UpO1xuXG4gIGdldCBhcmlhU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPyB0aGlzLl9tb2RlbC5zZWxlY3RlZC52YWx1ZSA9PT0gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRCA6IG51bGw7XG4gIH1cblxuICAvLyBBbGxvd3MgdGhlIGNvbnN1bWVyIHRvIG92ZXJyaWRlIG91ciBsb2dpYyBkZWNpZGluZyBpZiBhIG5vZGUgaXMgZXhwYW5kYWJsZS5cbiAgLy8gVXNlZnVsIGZvciByZWN1cnNpdmUgdHJlZXMgdGhhdCBkb24ndCB3YW50IHRvIHByZS1sb2FkIG9uZSBsZXZlbCBhaGVhZCBqdXN0IHRvIGtub3cgd2hpY2ggbm9kZXMgYXJlIGV4cGFuZGFibGUuXG4gIEBJbnB1dCgnY2xyRXhwYW5kYWJsZScpIGV4cGFuZGFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgLy8gSSdtIGNhdmluZyBvbiB0aGlzLCBmb3IgdHJlZSBub2RlcyBJIHRoaW5rIHdlIGNhbiB0b2xlcmF0ZSBoYXZpbmcgYSB0d28td2F5IGJpbmRpbmcgb24gdGhlIGNvbXBvbmVudFxuICAvLyByYXRoZXIgdGhhbiBlbmZvcmNlIHRoZSBjbHJJZkV4cGFuZGVkIHN0cnVjdHVyYWwgZGlyZWN0aXZlIGZvciBkeW5hbWljIGNhc2VzLiBNb3N0bHkgYmVjYXVzZSBmb3IgdGhlIHNtYXJ0XG4gIC8vIGNhc2UsIHlvdSBjYW4ndCB1c2UgYSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSwgaXQgd291bGQgbmVlZCB0byBnbyBvbiBhbiBuZy1jb250YWluZXIuXG4gIEBJbnB1dCgnY2xyRXhwYW5kZWQnKVxuICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZDtcbiAgfVxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckV4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnRlbnRDb250YWluZXJUYWJpbmRleCA9IC0xO1xuICBAVmlld0NoaWxkKCdjb250ZW50Q29udGFpbmVyJywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgcHJpdmF0ZSBjb250ZW50Q29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX21vZGVsLmV4cGFuZGVkID0gdGhpcy5leHBhbmRlZDtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX21vZGVsLnNlbGVjdGVkLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLnNraXBFbWl0Q2hhbmdlKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fbW9kZWwuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyLmZvY3VzUmVxdWVzdC5zdWJzY3JpYmUobm9kZUlkID0+IHtcbiAgICAgICAgaWYgKHRoaXMubm9kZUlkID09PSBub2RlSWQpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJlZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0NoYW5nZS5zdWJzY3JpYmUobm9kZUlkID0+IHtcbiAgICAgICAgdGhpcy5jaGVja1RhYkluZGV4KG5vZGVJZCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX21vZGVsLmxvYWRpbmckLnBpcGUoZGVib3VuY2VUaW1lKDApKS5zdWJzY3JpYmUoaXNMb2FkaW5nID0+ICh0aGlzLmlzTW9kZWxMb2FkaW5nID0gaXNMb2FkaW5nKSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fbW9kZWwuZGVzdHJveSgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvLyBAQ29udGVudENoaWxkIHdvdWxkIGhhdmUgYmVlbiBtb3JlIHN1Y2NpbmN0XG4gIC8vIGJ1dCBpdCBkb2Vzbid0IG9mZmVyIGEgd2F5IHRvIHF1ZXJ5IG9ubHkgYW4gaW1tZWRpYXRlIGNoaWxkXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyVHJlZU5vZGVMaW5rLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICBwcml2YXRlIHRyZWVOb2RlTGlua0xpc3Q6IFF1ZXJ5TGlzdDxDbHJUcmVlTm9kZUxpbms+O1xuXG4gIGdldCB0cmVlTm9kZUxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZU5vZGVMaW5rTGlzdCAmJiB0aGlzLnRyZWVOb2RlTGlua0xpc3QuZmlyc3Q7XG4gIH1cblxuICBwcml2YXRlIHNldFRhYkluZGV4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNvbnRlbnRDb250YWluZXJUYWJpbmRleCA9IHZhbHVlO1xuICAgIHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVGFiSW5kZXgobm9kZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLm5vZGVJZCAhPT0gbm9kZUlkICYmIHRoaXMuY29udGVudENvbnRhaW5lclRhYmluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgtMSk7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNUcmVlTm9kZSgpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgwKTtcbiAgICAgIHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgYnJvYWRjYXN0Rm9jdXNPbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLmZvY3VzTWFuYWdlci5icm9hZGNhc3RGb2N1c2VkTm9kZSh0aGlzLm5vZGVJZCk7XG4gIH1cblxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBUd28gcmVhc29ucyB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3I6XG4gICAgLy8gMS4gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gYXJyb3cga2V5c1xuICAgIC8vIDIuIEFzc2lzdGl2ZSBUZWNobm9sb2d5IGZvY3VzIGRpZmZlcnMgZnJvbSBLZXlib2FyZCBmb2N1cyBiZWhhdmlvci5cbiAgICAvLyAgICBCeSBkZWZhdWx0LCBwcmVzc2luZyBhcnJvdyBrZXkgbWFrZXMgQVQgZm9jdXMgZ28gaW50byB0aGUgbmVzdGVkIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAgcHJldmVudEFycm93S2V5U2Nyb2xsKGV2ZW50KTtcblxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMtMS4xLyNrZXlib2FyZC1pbnRlcmFjdGlvbi0yMlxuICAgIHN3aXRjaCAoa2V5VmFsaWRhdG9yKGV2ZW50LmtleSkpIHtcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dVcDpcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQWJvdmUodGhpcy5fbW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dEb3duOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVCZWxvdyh0aGlzLl9tb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd1JpZ2h0OlxuICAgICAgICB0aGlzLmV4cGFuZE9yRm9jdXNGaXJzdENoaWxkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd0xlZnQ6XG4gICAgICAgIHRoaXMuY29sbGFwc2VPckZvY3VzUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5Ib21lOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVuZDpcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNMYXN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVudGVyOlxuICAgICAgICB0aGlzLnRyaWdnZXJEZWZhdWx0QWN0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5TcGFjZTpcbiAgICAgICAgLy8gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gc3BhY2Uga2V5IGluIHRoaXMgc3BlY2lmaWMgY2FzZVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnRyaWdnZXJEZWZhdWx0QWN0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHBhbmRPckZvY3VzRmlyc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYWxyZWFkeSBleHBhbmRlZCBhbmQgaGFzIGNoaWxkcmVuLCBmb2N1cyBpdHMgdmVyeSBmaXJzdCBjaGlsZFxuICAgICAgaWYgKHRoaXMuX21vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQmVsb3codGhpcy5fbW9kZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBtdXN0IGNoZWNrIGlmIHRoZSBub2RlIGlzIGV4cGFuZGFibGUsIGluIG9yZGVyIHRvIHNldCAuZXhwYW5kZWQgdG8gdHJ1ZSBmcm9tIGZhbHNlXG4gICAgICAvLyBiZWNhdXNlIHdlIHNob3VsZG4ndCBzZXQgLmV4cGFuZGVkIHRvIHRydWUgaWYgaXQncyBub3QgZXhwYW5kYWJsZSBub2RlXG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoKSkge1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29sbGFwc2VPckZvY3VzUGFyZW50KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNQYXJlbnQodGhpcy5fbW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckRlZmF1bHRBY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudHJlZU5vZGVMaW5rKSB7XG4gICAgICB0aGlzLnRyZWVOb2RlTGluay5hY3RpdmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZSkge1xuICAgICAgICB0aGlzLl9tb2RlbC50b2dnbGVTZWxlY3Rpb24odGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19